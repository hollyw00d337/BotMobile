from typing import Any, Text, Dict, List
from rasa_sdk import Action, Tracker
from rasa_sdk.executor import CollectingDispatcher
from rasa_sdk.events import SlotSet
from config.image_config import ImageConfig
import logging
import re

logger = logging.getLogger(__name__)


def format_as_button_option(number: int, text: str) -> str:
    """
    Formatea un texto como opci√≥n de bot√≥n con identificadores.
    
    Args:
        number: N√∫mero de la opci√≥n (1, 2, 3, etc.)
        text: Texto de la opci√≥n
        
    Returns:
        Texto formateado como: "1Ô∏è‚É£ Texto de la opci√≥n."
    """
    # Mapear n√∫meros a emojis
    emoji_map = {
        1: "1Ô∏è‚É£", 2: "2Ô∏è‚É£", 3: "3Ô∏è‚É£", 4: "4Ô∏è‚É£", 5: "5Ô∏è‚É£",
        6: "6Ô∏è‚É£", 7: "7Ô∏è‚É£", 8: "8Ô∏è‚É£", 9: "9Ô∏è‚É£", 10: "üîü"
    }
    
    emoji = emoji_map.get(number, f"{number}Ô∏è‚É£")
    
    # Asegurar que termine con punto
    if not text.endswith('.'):
        text += '.'
    
    return f"{emoji} {text}"


def format_message_with_options(intro_text: str, options: List[str]) -> str:
    """
    Formatea un mensaje con texto introductorio y opciones numeradas.
    
    Args:
        intro_text: Texto introductorio (mensaje simple)
        options: Lista de opciones que ser√°n formateadas como botones
        
    Returns:
        Mensaje completo formateado
    """
    formatted_options = []
    for i, option in enumerate(options, 1):
        formatted_options.append(format_as_button_option(i, option))
    
    return f"{intro_text}\n\n" + "\n".join(formatted_options)


class ActionSessionStart(Action):
    """Acci√≥n personalizada para iniciar la sesi√≥n.
    Dise√±ada para trabajar exactamente con el c√≥digo Node-RED original.
    """
    
    def name(self) -> Text:
        return "action_session_start"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        print(f"[DEBUG ActionSessionStart] ‚ïê‚ïê‚ïê INICIANDO SESI√ìN ‚ïê‚ïê‚ïê")
        print(f"[DEBUG ActionSessionStart] Mensaje recibido: {tracker.latest_message}")
        
        # Enviar imagen de bienvenida
        dispatcher.utter_message(image=ImageConfig.BIENVENIDA_BOTMOBILE)
        
        # **IDENTIFICADOR DE INICIO DE CONVERSACI√ìN**
        inicio_conversacion_detectado = False
        mensaje_texto = None
        
        # Obtener el mensaje del usuario
        if tracker.latest_message:
            mensaje_texto = tracker.latest_message.get('text', '')
            print(f"[DEBUG ActionSessionStart] Texto extra√≠do: '{mensaje_texto}'")
        
        # Verificar identificadores especiales de Node-RED
        if mensaje_texto:
            mensaje_upper = mensaje_texto.upper().strip()
            
            # **IDENTIFICADOR DE INICIO**: Detectar inicio de conversaci√≥n
            if self._es_inicio_conversacion(mensaje_upper):
                print(f"[DEBUG ActionSessionStart] ‚úÖ INICIO DE CONVERSACI√ìN DETECTADO")
                inicio_conversacion_detectado = True
            
            # **PROCESAMIENTO DE COMPA√ë√çA**: Usar c√≥digo Node-RED exacto
            if self._es_mensaje_node_red(mensaje_texto):
                print(f"[DEBUG ActionSessionStart] ‚úÖ MENSAJE DE NODE-RED DETECTADO")
                
                # Extraer compa√±√≠a usando la l√≥gica exacta del Node-RED
                compania_detectada = self._extraer_compania_node_red(mensaje_texto)
                if compania_detectada:
                    print(f"[DEBUG ActionSessionStart] ‚úÖ Compa√±√≠a detectada: {compania_detectada}")
                    
                    mensaje_personalizado = self._crear_mensaje_personalizado_con_menu(compania_detectada)
                    dispatcher.utter_message(text=mensaje_personalizado)
                    
                    slots_to_set = [
                        SlotSet("compania_operador", compania_detectada),
                        SlotSet("estado_menu", "menu_principal"),
                        SlotSet("session_started", True),
                        SlotSet("inicio_conversacion", inicio_conversacion_detectado)
                    ]
                    
                    # Extraer n√∫mero si existe (formato Node-RED)
                    numero_extraido = self._extraer_numero_node_red(mensaje_texto)
                    if numero_extraido:
                        slots_to_set.append(SlotSet("numero_telefono", numero_extraido))
                        print(f"[DEBUG ActionSessionStart] ‚úÖ N√∫mero extra√≠do: {numero_extraido}")
                    
                    return slots_to_set
        
        print(f"[DEBUG ActionSessionStart] ‚ùå Mensaje gen√©rico, usando saludo por defecto")
        
        # Saludo gen√©rico por defecto con identificadores de botones
        intro_text = """üëã ¬°Hola! Soy BotMobile, tu asistente m√≥vil ‚òï
Estoy aqu√≠ para ayudarte a conectarte f√°cil, r√°pido y sin interrupciones üì∂

üì¶ Tenemos paquetes para todos los usos, con cobertura nacional.
Elige entre chip f√≠sico o eSIM, ¬°y hazlo todo desde aqu√≠!

üëá ¬øQu√© necesitas hoy?"""

        opciones = [
            "Conservar mi n√∫mero (portabilidad)",
            "Ver paquetes disponibles", 
            "Hablar con alguien del equipo"
        ]
        
        mensaje_menu = format_message_with_options(intro_text, opciones)
        mensaje_menu += "\n\n‚òï ¬°Vamos a hacerlo simple! Solo responde con el n√∫mero de la opci√≥n."
        
        dispatcher.utter_message(text=mensaje_menu)
        
        return [
            SlotSet("estado_menu", "menu_principal"),
            SlotSet("session_started", True),
            SlotSet("inicio_conversacion", inicio_conversacion_detectado)
        ]
    
    def _es_inicio_conversacion(self, mensaje_upper: str) -> bool:
        """
        Detecta identificadores de inicio de conversaci√≥n.
        Patrones comunes de Node-RED para inicio.
        """
        patrones_inicio = [
            r'^INICIO',
            r'^START',
            r'^BEGIN',
            r'^NUEVA_CONVERSACION',
            r'^NEW_CONVERSATION',
            r'INICIO_BOT',
            r'START_SESSION'
        ]
        
        for patron in patrones_inicio:
            if re.search(patron, mensaje_upper):
                return True
        
        return False
    
    def _es_mensaje_node_red(self, texto: str) -> bool:
        """
        Detecta si el mensaje proviene de Node-RED usando los patrones EXACTOS
        del c√≥digo que me enviaste.
        """
        if not texto:
            return False
            
        texto_upper = texto.upper()
        
        # **PATRONES EXACTOS DEL NODE-RED ORIGINAL**
        # Basado en tu funci√≥n24 original
        patrones_node_red = [
            # Formato: "COMPANIA_DETECTADA TELCEL"
            r'COMPANIA_DETECTADA\s+[A-Z&]+',
            
            # Formato: "OPERATOR TELCEL NUMERO 5512345678"
            r'OPERATOR\s+[A-Z&]+(\s+NUMERO\s+\d+)?',
            
            # Formato: "TELCEL NUMERO 5512345678" 
            r'(TELCEL|MOVISTAR|AT&T|UNEFON|VIRGIN|ALTAN)\s+(NUMERO\s+\d+)?',
            
            # Formato directo del operador
            r'^(TELCEL|MOVISTAR|AT&T|UNEFON|VIRGIN|ALTAN)$'
        ]
        
        for patron in patrones_node_red:
            if re.search(patron, texto_upper):
                print(f"[DEBUG] ‚úÖ Patr√≥n Node-RED detectado: {patron} en '{texto_upper}'")
                return True
        
        # **FORMATO NODE-RED ACTUAL**: nombres formateados de la base de datos
        # Lista de operadores v√°lidos seg√∫n el mapeo de function 28
        operadores_validos = {
            'Telcel', 'Movistar', 'AT&T', 'Unefon', 'Virgin', 'Altan', 'CFE', 'Walmart',
            'Quickly', 'Ibo Cell', 'Tel 360', 'Kubo', 'Virgin Mobile', 'Telecommerce',
            'MVH', 'Neus', 'Truu', 'Celmex', 'Eja', 'Logistica', 'Her', 'Comnet', 'Marduk',
            'Freedom', 'Hidalguense', 'Mobilebandits', 'Hip Cricket', 'Moluger', 'Altcel',
            'Inbtel', 'AINT', 'Islim', 'Airbus', 'Clearcom', 'Gurucomm', 'MBT', 'RTM',
            'Esmero', 'Talento', 'Oxio', 'Rocketel', 'Ads', 'Arloesi', 'Diri', 'Topos',
            'Wimo', 'Diveracy', 'Tridex', 'Exis', 'Ome', 'Edilar', 'Novavision', 'Guga',
            'Absoluteteck', 'Yonder', 'Cobranza', 'Tritium', 'Afcaza', 'Balesia', 'Rosa',
            'Telmov', 'Marketing', 'Bitelit', 'Orange', 'R&R', 'Viral', 'Oceannet',
            'Element', 'Broco', 'Allesklar', 'Lider', 'Secure', 'Gameplanet', 'Axios',
            'Celsfi', 'Maya', 'Telexes', 'Cambacel', 'Pantera', 'Othis', 'Femaseisa',
            'Alcance', 'Francisco', 'Valor', 'Pajal', 'Speednet', 'Liimaxtum', 'Yaqui',
            'Rex', 'Saavedra', 'Negocios', 'Nexbus', 'King', 'Bene', 'Elux', 'Igou',
            'Voztelecom', 'Abafon', 'Romel', 'Celmax', 'Alestra', 'VPN', 'Maxcom',
            'IENTC', 'OpenIP', 'Operbes', 'Cablevision', 'Plintron', 'Sev Tronc',
            'Megacable', 'Vasanta', 'Inten', 'Next', 'Guadiana', 'Solucionika', 'Abix',
            'Girnet', 'Fobos', 'Unet', 'Plasma', 'Tu Visi√≥n', 'Tele Imagen', 'Telgen',
            'Ultravision', 'Trends', 'Apco', 'Spot Uno', 'Uriel', 'Eni', 'At&t',
            'AXTEL', 'Convergia', 'Servnet', 'Vinoc', 'TELCEL' ,
        }
        
        if texto.strip() in operadores_validos:
            print(f"[DEBUG] ‚úÖ Operador Node-RED v√°lido detectado: '{texto}'")
            return True
        
        return False
    
    def _extraer_compania_node_red(self, texto: str) -> str:
        """
        Extrae la compa√±√≠a usando la l√≥gica EXACTA del Node-RED original.
        """
        if not texto:
            return None
            
        texto_upper = texto.upper()
        
        # **MAPEO EXACTO DEL NODE-RED**
        mapeo_companias = {
            'TELCEL': 'Telcel',
            'MOVISTAR': 'Movistar', 
            'AT&T': 'AT&T',
            'UNEFON': 'Unefon',
            'VIRGIN': 'Virgin Mobile',
            'ALTAN': 'Altan Redes'
        }
        
        # **PATRONES DE EXTRACCI√ìN (orden de prioridad)**
        
        # 1. Formato: "COMPANIA_DETECTADA TELCEL"
        match = re.search(r'COMPANIA_DETECTADA\s+([A-Z&]+)', texto_upper)
        if match:
            compania_raw = match.group(1)
            compania_final = mapeo_companias.get(compania_raw, compania_raw.capitalize())
            print(f"[DEBUG] Compa√±√≠a extra√≠da formato 1: {compania_raw} -> {compania_final}")
            return compania_final
        
        # 2. Formato especial: "OPERATOR SPOT UNO NUMERO xxx" (caso especial con espacio)
        match = re.search(r'OPERATOR\s+(SPOT\s+UNO)', texto_upper)
        if match:
            print(f"[DEBUG] Compa√±√≠a extra√≠da formato 2 especial: SPOT UNO -> Spot Uno")
            return "Spot Uno"
        
        # 3. Formato: "OPERATOR TELCEL NUMERO 5512345678" 
        match = re.search(r'OPERATOR\s+([A-Z&]+)', texto_upper)
        if match:
            compania_raw = match.group(1)
            compania_final = mapeo_companias.get(compania_raw, compania_raw.capitalize())
            print(f"[DEBUG] Compa√±√≠a extra√≠da formato 3: {compania_raw} -> {compania_final}")
            return compania_final
        
        # 4. Formato: "TELCEL NUMERO 5512345678"
        match = re.search(r'(TELCEL|MOVISTAR|AT&T|UNEFON|VIRGIN|ALTAN)', texto_upper)
        if match:
            compania_raw = match.group(1)
            compania_final = mapeo_companias.get(compania_raw, compania_raw.capitalize())
            print(f"[DEBUG] Compa√±√≠a extra√≠da formato 4: {compania_raw} -> {compania_final}")
            return compania_final
        
        # 5. Operador solo (formato directo)
        texto_limpio = texto_upper.strip()
        if texto_limpio in mapeo_companias:
            compania_final = mapeo_companias[texto_limpio]
            print(f"[DEBUG] Compa√±√≠a extra√≠da formato 5: {texto_limpio} -> {compania_final}")
            return compania_final
        
        # 5. Formato Node-RED actual: nombres formateados (ej: "Telcel", "CFE", "Walmart")
        texto_original = texto.strip()
        mapeo_nombres_formateados = {
            'Telcel': 'Telcel', 'Movistar': 'Movistar', 'AT&T': 'AT&T', 'Unefon': 'Unefon', 
            'Virgin': 'Virgin Mobile', 'Altan': 'Altan Redes', 'CFE': 'CFE', 'Walmart': 'Walmart',
            'Quickly': 'Quickly', 'Ibo Cell': 'Ibo Cell', 'Tel 360': 'Tel 360', 'Kubo': 'Kubo',
            'Virgin Mobile': 'Virgin Mobile', 'Telecommerce': 'Telecommerce', 'MVH': 'MVH', 'Neus': 'Neus',
            'Truu': 'Truu', 'Celmex': 'Celmex', 'Eja': 'Eja', 'Logistica': 'Logistica', 'Her': 'Her',
            'Comnet': 'Comnet', 'Marduk': 'Marduk', 'Freedom': 'Freedom', 'Hidalguense': 'Hidalguense',
            'Mobilebandits': 'Mobilebandits', 'Hip Cricket': 'Hip Cricket', 'Moluger': 'Moluger', 'Altcel': 'Altcel',
            'Inbtel': 'Inbtel', 'AINT': 'AINT', 'Islim': 'Islim', 'Airbus': 'Airbus', 'Clearcom': 'Clearcom',
            'Gurucomm': 'Gurucomm', 'MBT': 'MBT', 'RTM': 'RTM', 'Esmero': 'Esmero', 'Talento': 'Talento',
            'Oxio': 'Oxio', 'Rocketel': 'Rocketel', 'Ads': 'Ads', 'Arloesi': 'Arloesi', 'Diri': 'Diri',
            'Topos': 'Topos', 'Wimo': 'Wimo', 'Diveracy': 'Diveracy', 'Tridex': 'Tridex', 'Exis': 'Exis',
            'Ome': 'Ome', 'Edilar': 'Edilar', 'Novavision': 'Novavision', 'Guga': 'Guga', 
            'Absoluteteck': 'Absoluteteck', 'Yonder': 'Yonder', 'Cobranza': 'Cobranza', 'Tritium': 'Tritium',
            'Afcaza': 'Afcaza', 'Balesia': 'Balesia', 'Rosa': 'Rosa', 'Telmov': 'Telmov', 'Marketing': 'Marketing',
            'Bitelit': 'Bitelit', 'Orange': 'Orange', 'R&R': 'R&R', 'Viral': 'Viral', 'Oceannet': 'Oceannet',
            'Element': 'Element', 'Broco': 'Broco', 'Allesklar': 'Allesklar', 'Lider': 'Lider', 'Secure': 'Secure',
            'Gameplanet': 'Gameplanet', 'Axios': 'Axios', 'Celsfi': 'Celsfi', 'Maya': 'Maya', 'Telexes': 'Telexes',
            'Cambacel': 'Cambacel', 'Pantera': 'Pantera', 'Othis': 'Othis', 'Femaseisa': 'Femaseisa',
            'Alcance': 'Alcance', 'Francisco': 'Francisco', 'Valor': 'Valor', 'Pajal': 'Pajal',
            'Speednet': 'Speednet', 'Liimaxtum': 'Liimaxtum', 'Yaqui': 'Yaqui', 'Rex': 'Rex',
            'Saavedra': 'Saavedra', 'Negocios': 'Negocios', 'Nexbus': 'Nexbus', 'King': 'King',
            'Bene': 'Bene', 'Elux': 'Elux', 'Igou': 'Igou', 'Voztelecom': 'Voztelecom', 'Abafon': 'Abafon',
            'Romel': 'Romel', 'Celmax': 'Celmax', 'Alestra': 'Alestra', 'VPN': 'VPN', 'Maxcom': 'Maxcom',
            'IENTC': 'IENTC', 'OpenIP': 'OpenIP', 'Operbes': 'Operbes', 'Cablevision': 'Cablevision',
            'Plintron': 'Plintron', 'Sev Tronc': 'Sev Tronc', 'Megacable': 'Megacable', 'Vasanta': 'Vasanta',
            'Inten': 'Inten', 'Next': 'Next', 'Guadiana': 'Guadiana', 'Solucionika': 'Solucionika',
            'Abix': 'Abix', 'Girnet': 'Girnet', 'Fobos': 'Fobos', 'Unet': 'Unet', 'Plasma': 'Plasma',
            'Tu Visi√≥n': 'Tu Visi√≥n', 'Tele Imagen': 'Tele Imagen', 'Telgen': 'Telgen', 'Ultravision': 'Ultravision',
            'Trends': 'Trends', 'Apco': 'Apco', 'Spot Uno': 'Spot Uno', 'Uriel': 'Uriel', 'Eni': 'Eni',
            'At&t': 'AT&T'  # Mapeo especial para el formato de la base de datos
        }
        
        if texto_original in mapeo_nombres_formateados:
            compania_final = mapeo_nombres_formateados[texto_original]
            print(f"[DEBUG] Compa√±√≠a extra√≠da formato 5 (Node-RED): {texto_original} -> {compania_final}")
            return compania_final
        
        print(f"[DEBUG] ‚ùå No se pudo extraer compa√±√≠a de: '{texto}'")
        return None
    
    def _extraer_numero_node_red(self, texto: str) -> str:
        """
        Extrae el n√∫mero de tel√©fono usando los patrones del Node-RED original.
        """
        if not texto:
            return None
        
        # Patrones para extraer n√∫mero
        patrones_numero = [
            r'NUMERO\s+(\d{10,})',  # "NUMERO 5512345678"
            r'NUMBER\s+(\d{10,})',  # "NUMBER 5512345678" 
            r'(\d{10})',            # N√∫mero directo de 10 d√≠gitos
        ]
        
        texto_upper = texto.upper()
        
        for patron in patrones_numero:
            match = re.search(patron, texto_upper)
            if match:
                numero = match.group(1)
                print(f"[DEBUG] ‚úÖ N√∫mero extra√≠do: {numero}")
                return numero
        
        return None

    def _crear_mensaje_personalizado_con_menu(self, compania: str) -> str:
        """
        Crea mensaje personalizado basado en la compa√±√≠a del usuario con identificadores de botones.
        Exactamente como funciona con el Node-RED original.
        """
        
        mensajes_personalizados = {
            "Telcel": {
                "intro": """üéØ ¬°Hola! Detect√© que vienes de Telcel. Te ayudo con tu portabilidad a BotMobile de manera s√∫per f√°cil.

üí∞ ¬°Ahorra $80 pesos al mes!
Telcel: $300/mes por 8GB
BotMobile: $220/mes por 72GB

üëá ¬øQu√© necesitas hoy?""",
                "opciones": [
                    "Conservar mi n√∫mero (portabilidad)",
                    "Ver paquetes disponibles", 
                    "Hablar con alguien del equipo"
                ]
            },
            
            "AT&T": {
                "intro": """üéØ ¬°Perfecto! Detect√© que vienes de AT&T. 

üí∞ BotMobile te ofrece:
üì± 72GB por solo $220/mes
üé¨ Netflix + Disney+ + Prime incluido
üì∂ Cobertura nacional garantizada

üëá ¬øQu√© te interesa?""",
                "opciones": [
                    "Conservar mi n√∫mero (portabilidad)",
                    "Ver paquetes disponibles", 
                    "Hablar con alguien del equipo"
                ]
            },
            
            "Movistar": {
                "intro": """üéØ ¬°Hola! Veo que vienes de Movistar.

üí∏ Compara y ahorra:
Movistar: $350/mes por 10GB  
BotMobile: $220/mes por 72GB + streaming incluido

üëá ¬øC√≥mo te ayudo?""",
                "opciones": [
                    "Conservar mi n√∫mero (portabilidad)",
                    "Ver paquetes disponibles", 
                    "Hablar con alguien del equipo"
                ]
            },
            
            "Unefon": {
                "intro": """üéØ ¬°Hola! Detect√© que vienes de Unefon.

üöÄ Mejora tu experiencia:
‚úÖ M√°s datos por menos dinero
‚úÖ Cobertura nacional real
‚úÖ Streaming incluido sin costo extra

üëá ¬øQu√© necesitas?""",
                "opciones": [
                    "Conservar mi n√∫mero (portabilidad)",
                    "Ver paquetes disponibles", 
                    "Hablar con alguien del equipo"
                ]
            },
            
            "Virgin Mobile": {
                "intro": """üéØ ¬°Hola! Veo que vienes de Virgin Mobile.

‚ö° Velocidad real + m√°s beneficios:
üì± 72GB de alta velocidad
üé¨ Plataformas de streaming incluidas
üì∂ Red nacional de calidad

üëá ¬øC√≥mo puedo ayudarte?""",
                "opciones": [
                    "Conservar mi n√∫mero (portabilidad)",
                    "Ver paquetes disponibles", 
                    "Hablar con alguien del equipo"
                ]
            },
            
            "Altan Redes": {
                "intro": """üéØ ¬°Perfecto! Detect√© que vienes de Altan Redes.

üí´ Migraci√≥n s√∫per sencilla:
‚úÖ Conservas tu n√∫mero
‚úÖ M√°s datos, mismo precio
‚úÖ Sin complicaciones

üëá ¬øQu√© te gustar√≠a saber?""",
                "opciones": [
                    "Conservar mi n√∫mero (portabilidad)",
                    "Ver paquetes disponibles", 
                    "Hablar con alguien del equipo"
                ]
            },
            
            "Spot Uno": {
                "intro": """üéØ ¬°Hola! Detect√© que vienes de Spot Uno.

üí∞ ¬°Es hora de una actualizaci√≥n!
‚ú® BotMobile te ofrece mucho m√°s:
üì± 72GB por solo $220/mes
üé¨ Netflix + Disney+ + Prime incluido
üì∂ Cobertura nacional superior

üëá ¬øQu√© te interesa conocer?""",
                "opciones": [
                    "Conservar mi n√∫mero (portabilidad)",
                    "Ver paquetes disponibles", 
                    "Hablar con alguien del equipo"
                ]
            }
        }
        
        if compania in mensajes_personalizados:
            config = mensajes_personalizados[compania]
            mensaje = format_message_with_options(config["intro"], config["opciones"])
        else:
            # Mensaje gen√©rico para operadores no espec√≠ficamente configurados
            intro = f"""üéØ ¬°Hola! Detect√© que vienes de {compania}.

üí∞ BotMobile te ofrece m√°s por menos:
üì± 72GB por solo $220/mes
üé¨ Netflix + Disney+ + Prime incluido
üì∂ Cobertura nacional garantizada

üëá ¬øC√≥mo te ayudo?"""
            
            opciones = [
                "Conservar mi n√∫mero (portabilidad)",
                "Ver paquetes disponibles", 
                "Hablar con alguien del equipo"
            ]
            mensaje = format_message_with_options(intro, opciones)
        
        mensaje += "\n\n‚òï ¬°Vamos a hacerlo simple! Solo responde con el n√∫mero de la opci√≥n."
        return mensaje


class ActionFinalizarConversacion(Action):
    """
    **IDENTIFICADOR DE FIN DE CONVERSACI√ìN**
    Maneja el cierre de conversaciones y cleanup.
    """
    
    def name(self) -> Text:
        return "action_finalizar_conversacion"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        print(f"[DEBUG ActionFinalizarConversacion] ‚ïê‚ïê‚ïê FINALIZANDO CONVERSACI√ìN ‚ïê‚ïê‚ïê")
        
        # Mensaje de despedida con identificadores
        intro_text = """üëã ¬°Gracias por contactar BotMobile!

üéØ Recuerda:
üì± Siempre tenemos los mejores planes
üí¨ Estamos aqu√≠ cuando nos necesites
üöÄ Tu portabilidad es gratis y sencilla

‚ú® ¬øNecesitas algo m√°s?"""
        
        opciones = [
            "Volver al men√∫ principal",
            "Hablar con el equipo", 
            "Finalizar conversaci√≥n"
        ]
        
        mensaje_despedida = format_message_with_options(intro_text, opciones)
        dispatcher.utter_message(text=mensaje_despedida)
        
        return [
            SlotSet("estado_menu", "despedida"),
            SlotSet("conversation_ending", True)
        ]


class ActionElegirOpcion(Action):
    """Maneja las opciones del men√∫ principal con identificadores de botones"""
    
    def name(self) -> Text:
        return "action_elegir_opcion"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        # Obtener la opci√≥n seleccionada
        numero_opcion = None
        entities = tracker.latest_message.get('entities', [])
        
        for entity in entities:
            if entity.get('entity') == 'numero_opcion':
                numero_opcion = entity.get('value')
                break
        
        # Si no se encontr√≥ en entities, buscar en el texto
        if not numero_opcion:
            texto = tracker.latest_message.get('text', '')
            match = re.search(r'(\d+)', texto)
            if match:
                numero_opcion = match.group(1)
        
        print(f"[DEBUG ActionElegirOpcion] Opci√≥n seleccionada: {numero_opcion}")
        
        compania_operador = tracker.get_slot("compania_operador")
        
        if numero_opcion == "1":
            # Portabilidad
            if compania_operador:
                # Mensaje personalizado para portabilidad
                intro_text = f"""üîÑ ¬°Perfecto! Te ayudo con la portabilidad desde {compania_operador}.

üìã Necesitar√°s:
üì± Tu n√∫mero actual activo
üÜî Tu NIP de portabilidad
üìÑ Identificaci√≥n oficial

üëá ¬øC√≥mo quieres continuar?"""
                
                opciones = [
                    "Solicitar mi NIP de portabilidad",
                    "Ya tengo mi NIP, continuar",
                    "Volver al men√∫ principal"
                ]
            else:
                intro_text = """üîÑ ¬°Excelente elecci√≥n! La portabilidad es gratis y sencilla.

üìã Proceso simple:
1Ô∏è‚É£ Solicitas tu NIP a tu operador actual
2Ô∏è‚É£ Nos proporcionas tus datos
3Ô∏è‚É£ ¬°Listo! Conservas tu n√∫mero

üëá ¬øNecesitas ayuda con alg√∫n paso?"""
                
                opciones = [
                    "¬øC√≥mo obtener mi NIP?",
                    "Ya tengo mi NIP",
                    "Volver al men√∫ principal"
                ]
            
            mensaje = format_message_with_options(intro_text, opciones)
            dispatcher.utter_message(text=mensaje)
            
            return [SlotSet("estado_menu", "portabilidad")]
            
        elif numero_opcion == "2":
            # Ver paquetes
            dispatcher.utter_message(image=ImageConfig.PAQUETES_PROMOCION)
            
            intro_text = """üì¶ Nuestros Planes BotMobile:

üî• Plan Ilimitado - $220/mes
üì± 72GB + Ilimitadas llamadas
üé¨ Netflix + Disney+ + Prime Video
üì∂ Cobertura nacional

üíé Plan Premium - $300/mes  
üì± 100GB + Todo ilimitado
üéÆ Gaming sin lag
üé¨ Todas las plataformas incluidas

üëá ¬øQu√© te interesa?"""
            
            opciones = [
                "Contratar Plan Ilimitado $220",
                "Contratar Plan Premium $300", 
                "Volver al men√∫ principal"
            ]
            
            mensaje = format_message_with_options(intro_text, opciones)
            dispatcher.utter_message(text=mensaje)
            
            return [SlotSet("estado_menu", "paquetes")]
            
        elif numero_opcion == "3":
            # Hablar con el equipo
            intro_text = """üë• Contacta a nuestro equipo

üì≤ WhatsApp: +52 614 558 7289

‚ö° Nuestro equipo te ayudar√° con:
‚Ä¢ Detalles de cada paquete
‚Ä¢ Disponibilidad en tu zona
‚Ä¢ Proceso de activaci√≥n
‚Ä¢ Resolver cualquier duda

ÔøΩ Horarios de atenci√≥n:
‚Ä¢ Lunes a Viernes: 9:00 - 18:00
‚Ä¢ S√°bados: 9:00 - 14:00

0Ô∏è‚É£ Volver al men√∫ principal"""
            
            dispatcher.utter_message(text=intro_text)
            
            return [SlotSet("estado_menu", "contacto")]
        else:
            # Opci√≥n no v√°lida
            dispatcher.utter_message(text="Opci√≥n no v√°lida. Por favor elige un n√∫mero del 1 al 3.")
            return []


class ActionDefaultFallback(Action):
    """Acci√≥n de fallback cuando no se entiende el mensaje"""
    
    def name(self) -> Text:
        return "action_default_fallback"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        # Mensaje de fallback amigable con identificadores
        intro_text = """ü§î No estoy seguro de entender. 

üëã Puedo ayudarte con:
üì± Portabilidad (conservar tu n√∫mero)
üì¶ Ver nuestros planes
üë• Contactar con el equipo

üëá ¬øQu√© necesitas?"""
        
        opciones = [
            "Conservar mi n√∫mero (portabilidad)",
            "Ver paquetes disponibles", 
            "Hablar con alguien del equipo"
        ]
        
        mensaje = format_message_with_options(intro_text, opciones)
        dispatcher.utter_message(text=mensaje)
        
        return [SlotSet("estado_menu", "menu_principal")]
